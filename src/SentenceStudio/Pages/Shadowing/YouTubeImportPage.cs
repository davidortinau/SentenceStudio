using MauiReactor.Compatibility;
using MauiReactor.Shapes;
using Microsoft.Extensions.Logging;
using UXDivers.Popups.Maui.Controls;
using UXDivers.Popups.Services;

namespace SentenceStudio.Pages.YouTube;

class YouTubeImportState
{
    public string VideoUrl { get; set; } = string.Empty;
    public string ErrorMessage { get; set; } = string.Empty;

    public List<TranscriptTrack> AvailableTranscripts { get; set; } = new();
    public TranscriptTrack SelectedTranscript { get; set; }
    public string TranscriptText { get; set; } = string.Empty;
    public bool IsLoadingTranscripts { get; set; } = false;
    public bool ShowTranscriptPicker { get; set; } = false;
    public string TranscriptMessage { get; set; } = string.Empty;
    public bool IsSavingResource { get; set; } = false;
    public int? SavedResourceId { get; set; } = null;
    public bool IsPolishingTranscript { get; set; } = false;
}

partial class YouTubeImportPage : Component<YouTubeImportState>
{
    [Inject] YouTubeImportService _youtubeImportService;
    [Inject] UserProfileRepository _userProfileRepository;
    [Inject] LearningResourceRepository _learningResourceRepository;
    [Inject] TranscriptFormattingService _formattingService;
    [Inject] ILogger<YouTubeImportPage> _logger;
    LocalizationManager _localize => LocalizationManager.Instance;

    public override VisualNode Render()
    {
        return ContentPage($"{_localize["ImportFromYouTube"]}",
            ToolbarItem($"{_localize["Clear"]}")
                .OnClicked(ClearPage),

            Grid(
                ScrollView(
                    VStack(spacing: 16,
                        Label($"{_localize["ImportAudioClipFromYouTube"]}")
                        .H4(),

                    Border(
                        Entry()
                            .Text(State.VideoUrl)
                            .Placeholder($"{_localize["YouTubeURL"]}")
                            .OnTextChanged((url) => SetState(s => s.VideoUrl = url))
                    )
                        .BackgroundColor(BootstrapTheme.Current.GetSurface())
                        .Stroke(BootstrapTheme.Current.GetOutline())
                        .StrokeThickness(1)
                        .StrokeShape(new RoundRectangle().CornerRadius(8))
                        .Padding(4),

                    Button($"{_localize["FetchTranscripts"]}")
                        .OnClicked(FetchTranscriptsAsync)
                        .IsEnabled(!State.IsLoadingTranscripts && !string.IsNullOrEmpty(State.VideoUrl))
                        .HStart(),

                Label(State.ErrorMessage)
                    .IsVisible(!string.IsNullOrEmpty(State.ErrorMessage)),

                Label(State.TranscriptMessage)
                    .IsVisible(!string.IsNullOrEmpty(State.TranscriptMessage)),

                // Transcript picker (when multiple transcripts available)
                VStack(
                    Label($"{_localize["SelectTranscriptLanguage"]}")
                        .Muted()
                        .Small(),
                    Border(
                        Picker()
                            .ItemsSource(State.AvailableTranscripts.Select(t => t.LanguageName).ToList())
                            .SelectedIndex(State.AvailableTranscripts.IndexOf(State.SelectedTranscript))
                            .OnSelectedIndexChanged(async (index) =>
                            {
                                if (index >= 0 && index < State.AvailableTranscripts.Count)
                                {
                                    var selected = State.AvailableTranscripts[index];
                                    SetState(s => s.SelectedTranscript = selected);
                                    await LoadTranscriptAsync(selected);
                                }
                            })
                    )
                        .BackgroundColor(BootstrapTheme.Current.GetSurface())
                        .Stroke(BootstrapTheme.Current.GetOutline())
                        .StrokeThickness(1)
                        .StrokeShape(new RoundRectangle().CornerRadius(8))
                        .Padding(4)
                )
                    .IsVisible(State.ShowTranscriptPicker),

                VStack(
                    Label($"{_localize["Language"]}: {State.SelectedTranscript?.LanguageName ?? "None"}")
                        .IsVisible(State.SelectedTranscript != null),

                    Label(State.SelectedTranscript?.IsAutoGenerated == true ? $"{_localize["AutoGenerated"]}" : $"{_localize["Manual"]}")
                        .IsVisible(State.SelectedTranscript != null)
                        .FontSize(12)
                )
                .IsVisible(State.SelectedTranscript != null && State.ShowTranscriptPicker),

                // Transcript display
                VStack(
                    Label($"{_localize["Transcript"]}")
                        .Muted()
                        .Small(),
                    Border(
                        Editor()
                            .Text(State.TranscriptText)
                            .OnTextChanged(text => SetState(s => s.TranscriptText = text))
                            .MinimumHeightRequest(200)
                            .AutoSize(EditorAutoSizeOption.TextChanges)
                    )
                        .BackgroundColor(BootstrapTheme.Current.GetSurface())
                        .Stroke(BootstrapTheme.Current.GetOutline())
                        .StrokeThickness(1)
                        .StrokeShape(new RoundRectangle().CornerRadius(8))
                        .Padding(4)
                )
                    .IsVisible(!string.IsNullOrEmpty(State.TranscriptText)),

                // Polish with AI button
                Button($"{_localize["PolishWithAI"]}")
                    .OnClicked(PolishTranscriptWithAi)
                    .IsEnabled(!State.IsPolishingTranscript && !string.IsNullOrEmpty(State.TranscriptText))
                    .IsVisible(!string.IsNullOrEmpty(State.TranscriptText))
                    .HStart(),

                // Save transcript button
                Button($"{_localize["SaveAsLearningResource"]}")
                    .OnClicked(SaveTranscriptAsResource)
                    .IsEnabled(!State.IsSavingResource && !string.IsNullOrEmpty(State.TranscriptText))
                    .IsVisible(!string.IsNullOrEmpty(State.TranscriptText) && State.SavedResourceId == null)
            )
            .Padding(new Thickness(15))
            ),

            // Activity indicator overlay for polishing
            State.IsPolishingTranscript ?
                Grid(
                    BoxView()
                        .Background(Colors.Black.WithAlpha(0.5f)),

                    VStack(spacing: 15,
                        ActivityIndicator()
                            .IsRunning(true)
                            .Color(Colors.White),

                        Label($"{_localize["PolishingTranscriptWithAI"]}")
                            .TextColor(Colors.White)
                            .FontSize(16)
                            .HorizontalTextAlignment(TextAlignment.Center),

                        Label("Please wait, this may take a moment")
                            .TextColor(Colors.White.WithAlpha(0.8f))
                            .FontSize(14)
                            .HorizontalTextAlignment(TextAlignment.Center)
                    )
                    .VCenter()
                    .HCenter()
                    .Padding(30)
                )
                : null
            )
        );
    }

    async Task FetchTranscriptsAsync()
    {
        try
        {
            SetState(s =>
            {
                s.IsLoadingTranscripts = true;
                s.TranscriptMessage = "Fetching available transcripts...";
                s.ErrorMessage = string.Empty;
            });

            var tracks = await _youtubeImportService.GetAvailableTranscriptsAsync(State.VideoUrl);

            if (tracks.Count == 0)
            {
                SetState(s =>
                {
                    s.TranscriptMessage = "No transcripts available for this video.";
                    s.IsLoadingTranscripts = false;
                });
                return;
            }

            // Get user's language preferences
            var profile = await _userProfileRepository.GetAsync();
            var targetLangCode = GetLanguageCode(profile?.TargetLanguage ?? "Korean");
            var nativeLangCode = GetLanguageCode(profile?.NativeLanguage ?? "English");

            // Try to find preferred transcript
            var preferredTrack = tracks.FirstOrDefault(t => t.LanguageCode.StartsWith(targetLangCode, StringComparison.OrdinalIgnoreCase))
                              ?? tracks.FirstOrDefault(t => t.LanguageCode.StartsWith(nativeLangCode, StringComparison.OrdinalIgnoreCase))
                              ?? tracks.FirstOrDefault();

            SetState(s =>
            {
                s.AvailableTranscripts = tracks;
                s.SelectedTranscript = preferredTrack;
                s.IsLoadingTranscripts = false;
            });

            if (tracks.Count == 1)
            {
                // Auto-load if only one transcript
                SetState(s => s.TranscriptMessage = $"Found transcript in {preferredTrack.LanguageName}. Loading...");
                await LoadTranscriptAsync(preferredTrack);
            }
            else
            {
                // Show picker for multiple transcripts
                SetState(s =>
                {
                    s.ShowTranscriptPicker = true;
                    s.TranscriptMessage = $"Found {tracks.Count} transcripts. Select your preferred language below.";
                });

                // Auto-load the preferred transcript
                await LoadTranscriptAsync(preferredTrack);
            }
        }
        catch (Exception ex)
        {
            SetState(s =>
            {
                s.ErrorMessage = $"Failed to fetch transcripts: {ex.Message}";
                s.TranscriptMessage = string.Empty;
                s.IsLoadingTranscripts = false;
            });
        }
    }

    async Task LoadTranscriptAsync(TranscriptTrack track)
    {
        try
        {
            SetState(s => s.TranscriptMessage = $"Loading {track.LanguageName} transcript...");

            var transcriptText = await _youtubeImportService.DownloadTranscriptTextAsync(track);

            // Auto-cleanup the transcript
            var cleanedText = _formattingService.SmartCleanup(transcriptText, track.LanguageName);

            SetState(s =>
            {
                s.TranscriptText = cleanedText;
                s.TranscriptMessage = $"Transcript loaded and cleaned in {track.LanguageName}" +
                    (track.IsAutoGenerated ? " (auto-generated)" : " (manual)");
            });
        }
        catch (Exception ex)
        {
            SetState(s =>
            {
                s.ErrorMessage = $"Failed to load transcript: {ex.Message}";
                s.TranscriptMessage = string.Empty;
            });
        }
    }

    string GetLanguageCode(string language) => language switch
    {
        "Korean" => "ko",
        "English" => "en",
        "Spanish" => "es",
        "Japanese" => "ja",
        "Chinese" => "zh",
        "French" => "fr",
        "German" => "de",
        "Italian" => "it",
        "Portuguese" => "pt",
        "Russian" => "ru",
        _ => "en"
    };

    string CleanLanguageName(string languageName)
    {
        if (string.IsNullOrWhiteSpace(languageName))
            return languageName;

        // Remove common YouTube transcript suffixes
        var patterns = new[]
        {
            " (auto-generated)",
            " (auto generated)",
            " (autogenerated)",
            " - auto-generated",
            " [auto-generated]",
            " (automatic)"
        };

        var cleaned = languageName;
        foreach (var pattern in patterns)
        {
            cleaned = cleaned.Replace(pattern, "", StringComparison.OrdinalIgnoreCase);
        }

        return cleaned.Trim();
    }

    async Task SaveTranscriptAsResource()
    {
        try
        {
            SetState(s => s.IsSavingResource = true);

            // Get video metadata
            var videoId = YoutubeExplode.Videos.VideoId.Parse(State.VideoUrl);
            var video = await _youtubeImportService.GetVideoMetadataAsync(videoId.ToString());

            // Check for duplicates
            var duplicateByUrl = await _learningResourceRepository.FindDuplicateByMediaUrlAsync(State.VideoUrl);
            var duplicateByTitle = await _learningResourceRepository.FindDuplicateByTitleAsync(video.Title);

            if (duplicateByUrl != null)
            {
                SetState(s => s.IsSavingResource = false);

                var overwriteTcs = new TaskCompletionSource<bool>();
                var overwritePopup = new SimpleActionPopup
                {
                    Title = "Duplicate Found",
                    Text = $"A resource with this YouTube URL already exists:\n\n\"{duplicateByUrl.Title}\"\n\nDo you want to view the existing resource instead of creating a duplicate?",
                    ActionButtonText = "View Existing",
                    SecondaryActionButtonText = "Create Anyway",
                    CloseWhenBackgroundIsClicked = false,
                    ActionButtonCommand = new Command(async () =>
                    {
                        overwriteTcs.TrySetResult(true);
                        await IPopupService.Current.PopAsync();
                    }),
                    SecondaryActionButtonCommand = new Command(async () =>
                    {
                        overwriteTcs.TrySetResult(false);
                        await IPopupService.Current.PopAsync();
                    })
                };
                await IPopupService.Current.PushAsync(overwritePopup);
                var overwrite = await overwriteTcs.Task;

                if (overwrite)
                {
                    // Navigate to existing resource
                    await MauiControls.Shell.Current.GoToAsync<LearningResources.ResourceProps>(
                        nameof(LearningResources.EditLearningResourcePage),
                        props => props.ResourceID = duplicateByUrl.Id);
                    return;
                }
            }
            else if (duplicateByTitle != null)
            {
                SetState(s => s.IsSavingResource = false);

                var proceedTcs = new TaskCompletionSource<bool>();
                var proceedPopup = new SimpleActionPopup
                {
                    Title = "Similar Title Found",
                    Text = $"A resource with a similar title already exists:\n\n\"{duplicateByTitle.Title}\"\n\nAre you sure you want to create a new resource?",
                    ActionButtonText = "Create New",
                    SecondaryActionButtonText = "Cancel",
                    CloseWhenBackgroundIsClicked = false,
                    ActionButtonCommand = new Command(async () =>
                    {
                        proceedTcs.TrySetResult(true);
                        await IPopupService.Current.PopAsync();
                    }),
                    SecondaryActionButtonCommand = new Command(async () =>
                    {
                        proceedTcs.TrySetResult(false);
                        await IPopupService.Current.PopAsync();
                    })
                };
                await IPopupService.Current.PushAsync(proceedPopup);
                var proceed = await proceedTcs.Task;

                if (!proceed)
                {
                    return;
                }

                SetState(s => s.IsSavingResource = true);
            }

            // Get user profile for language
            var profile = await _userProfileRepository.GetAsync();
            var rawLanguage = State.SelectedTranscript?.LanguageName ?? profile?.TargetLanguage ?? "Korean";
            var language = CleanLanguageName(rawLanguage);

            _logger.LogDebug("ðŸ”§ Language mapping: '{RawLanguage}' -> '{Language}'", rawLanguage, language);

            // Create learning resource
            var resource = new LearningResource
            {
                Title = video.Title ?? "YouTube Video",
                Description = video.Description ?? $"Imported from YouTube: {State.VideoUrl}",
                Language = language,
                MediaType = "Video",
                MediaUrl = State.VideoUrl,
                Transcript = State.TranscriptText,
                Tags = "youtube,video,transcript",
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };

            // Save the resource - this updates the resource.Id property
            await _learningResourceRepository.SaveResourceAsync(resource);

            // Now resource.Id contains the correct ID from the database
            var resourceId = resource.Id;

            SetState(s =>
            {
                s.IsSavingResource = false;
                s.SavedResourceId = resourceId;
            });

            // Ask user if they want to view the resource
            var viewResourceTcs = new TaskCompletionSource<bool>();
            var viewResourcePopup = new SimpleActionPopup
            {
                Title = "Success",
                Text = "Transcript saved as learning resource! Would you like to view it now?",
                ActionButtonText = "Yes",
                SecondaryActionButtonText = "No",
                CloseWhenBackgroundIsClicked = false,
                ActionButtonCommand = new Command(async () =>
                {
                    viewResourceTcs.TrySetResult(true);
                    await IPopupService.Current.PopAsync();
                }),
                SecondaryActionButtonCommand = new Command(async () =>
                {
                    viewResourceTcs.TrySetResult(false);
                    await IPopupService.Current.PopAsync();
                })
            };
            await IPopupService.Current.PushAsync(viewResourcePopup);
            var viewResource = await viewResourceTcs.Task;

            if (viewResource)
            {
                await MauiControls.Shell.Current.GoToAsync<LearningResources.ResourceProps>(
                    nameof(LearningResources.EditLearningResourcePage),
                    props => props.ResourceID = resourceId);
            }
        }
        catch (Exception ex)
        {
            SetState(s =>
            {
                s.IsSavingResource = false;
                s.ErrorMessage = $"Failed to save resource: {ex.Message}";
            });
        }
    }

    void ClearPage()
    {
        SetState(s =>
        {
            s.VideoUrl = string.Empty;
            s.ErrorMessage = string.Empty;
            s.AvailableTranscripts = new();
            s.SelectedTranscript = null;
            s.TranscriptText = string.Empty;
            s.IsLoadingTranscripts = false;
            s.ShowTranscriptPicker = false;
            s.TranscriptMessage = string.Empty;
            s.IsSavingResource = false;
            s.SavedResourceId = null;
        });
    }

    async Task PolishTranscriptWithAi()
    {
        try
        {
            SetState(s =>
            {
                s.IsPolishingTranscript = true;
                s.ErrorMessage = string.Empty;
                s.TranscriptMessage = "Polishing transcript with AI...";
            });

            var rawLanguage = State.SelectedTranscript?.LanguageName;
            var language = CleanLanguageName(rawLanguage);
            _logger.LogDebug("ðŸ”§ Language for AI polishing: '{RawLanguage}' -> '{Language}'", rawLanguage, language);

            var polished = await _formattingService.PolishWithAiAsync(State.TranscriptText, language);

            SetState(s =>
            {
                s.TranscriptText = polished;
                s.IsPolishingTranscript = false;
                s.TranscriptMessage = "Transcript polished with AI!";
            });
        }
        catch (Exception ex)
        {
            SetState(s =>
            {
                s.IsPolishingTranscript = false;
                s.ErrorMessage = $"Failed to polish transcript: {ex.Message}";
                s.TranscriptMessage = string.Empty;
            });
        }
    }
}